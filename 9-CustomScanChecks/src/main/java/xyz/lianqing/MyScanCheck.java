package xyz.lianqing;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.core.Marker;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.scanner.AuditResult;
import burp.api.montoya.scanner.ConsolidationAction;
import burp.api.montoya.scanner.ScanCheck;
import burp.api.montoya.scanner.audit.insertionpoint.AuditInsertionPoint;
import burp.api.montoya.scanner.audit.issues.AuditIssue;
import burp.api.montoya.scanner.audit.issues.AuditIssueConfidence;
import burp.api.montoya.scanner.audit.issues.AuditIssueSeverity;

import java.util.LinkedList;
import java.util.List;

import static burp.api.montoya.core.ByteArray.byteArray;
import static burp.api.montoya.scanner.AuditResult.auditResult;
import static burp.api.montoya.scanner.ConsolidationAction.KEEP_BOTH;
import static burp.api.montoya.scanner.ConsolidationAction.KEEP_EXISTING;
import static burp.api.montoya.scanner.audit.issues.AuditIssue.auditIssue;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;

/**
 * 自定义扫描检查实现类
 * 实现了 ScanCheck 接口，用于执行自定义的安全扫描检查
 * 
 * 主要功能：
 * 1. 执行主动扫描检查，检测命令注入漏洞
 * 2. 执行被动扫描检查，检测敏感信息泄露
 * 3. 提供问题合并策略
 */
class MyScanCheck implements ScanCheck
{
    private static final String GREP_STRING = "Page generated by:";  // 用于检测 CMS 信息泄露的字符串
    private static final String INJ_TEST = "|";                     // 用于测试命令注入的字符串
    private static final String INJ_ERROR = "Unexpected pipe";      // 命令注入错误提示

    private final MontoyaApi api;  // Burp API 接口实例

    /**
     * 构造函数
     * 
     * @param api Burp API 接口实例
     */
    MyScanCheck(MontoyaApi api)
    {
        this.api = api;
    }

    /**
     * 执行主动扫描检查
     * 检测命令注入漏洞
     * 
     * @param baseRequestResponse 基础请求响应
     * @param auditInsertionPoint 审计插入点
     * @return 审计结果
     */
    @Override
    public AuditResult activeAudit(HttpRequestResponse baseRequestResponse, AuditInsertionPoint auditInsertionPoint)
    {
        // 构建包含测试字符串的请求
        HttpRequest checkRequest = auditInsertionPoint.buildHttpRequestWithPayload(byteArray(INJ_TEST)).withService(baseRequestResponse.httpService());

        // 发送请求并获取响应
        HttpRequestResponse checkRequestResponse = api.http().sendRequest(checkRequest);

        // 获取响应中的高亮标记
        List<Marker> responseHighlights = getResponseHighlights(checkRequestResponse, INJ_ERROR);

        // 根据检查结果创建审计问题
        List<AuditIssue> auditIssueList = responseHighlights.isEmpty() ? emptyList() : singletonList(
                auditIssue(
                        "管道注入漏洞",
                        "提交管道字符返回了错误信息: " + INJ_ERROR,
                        null,
                        baseRequestResponse.request().url(),
                        AuditIssueSeverity.HIGH,
                        AuditIssueConfidence.CERTAIN,
                        null,
                        null,
                        AuditIssueSeverity.HIGH,
                        checkRequestResponse.withResponseMarkers(responseHighlights)
                )
        );

        return auditResult(auditIssueList);
    }

    /**
     * 执行被动扫描检查
     * 检测 CMS 信息泄露
     * 
     * @param baseRequestResponse 基础请求响应
     * @return 审计结果
     */
    @Override
    public AuditResult passiveAudit(HttpRequestResponse baseRequestResponse)
    {
        // 获取响应中的高亮标记
        List<Marker> responseHighlights = getResponseHighlights(baseRequestResponse, GREP_STRING);

        // 根据检查结果创建审计问题
        List<AuditIssue> auditIssueList = responseHighlights.isEmpty() ? emptyList() : singletonList(
                auditIssue(
                        "CMS 信息泄露",
                        "响应中包含敏感字符串: " + GREP_STRING,
                        null,
                        baseRequestResponse.request().url(),
                        AuditIssueSeverity.HIGH,
                        AuditIssueConfidence.CERTAIN,
                        null,
                        null,
                        AuditIssueSeverity.HIGH,
                        baseRequestResponse.withResponseMarkers(responseHighlights)
                )
        );

        return auditResult(auditIssueList);
    }

    /**
     * 合并重复的审计问题
     * 
     * @param newIssue 新发现的问题
     * @param existingIssue 已存在的问题
     * @return 合并操作
     */
    @Override
    public ConsolidationAction consolidateIssues(AuditIssue newIssue, AuditIssue existingIssue)
    {
        return existingIssue.name().equals(newIssue.name()) ? KEEP_EXISTING : KEEP_BOTH;
    }

    /**
     * 获取响应中的高亮标记
     * 用于标记匹配的字符串位置
     * 
     * @param requestResponse 请求响应
     * @param match 要匹配的字符串
     * @return 高亮标记列表
     */
    private static List<Marker> getResponseHighlights(HttpRequestResponse requestResponse, String match)
    {
        List<Marker> highlights = new LinkedList<>();
        String response = requestResponse.response().toString();

        int start = 0;

        // 查找所有匹配的字符串位置
        while (start < response.length())
        {
            start = response.indexOf(match, start);

            if (start == -1)
            {
                break;
            }

            // 创建高亮标记
            Marker marker = Marker.marker(start, start+match.length());
            highlights.add(marker);

            start += match.length();
        }

        return highlights;
    }
}